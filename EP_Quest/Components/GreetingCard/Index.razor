@using EP_Quest.Components.Shared
@using EP_Quest.Services.Classes
@inject DropboxService DService
@inject IJSRuntime JSRuntime
@inject IWebHostEnvironment HostingEnvironment

<Preloader IsLoading="IsLoading"></Preloader>

<div class="overlay">
    <div class="text-container">
        <p id="printed-text">@CurrentText</p>
    </div>
</div>

<canvas id="render-canvas"></canvas>

@code {
    public static event Action OnUpdate = delegate { };
    private static bool IsLoading { get; set; }
    private const string SceneName = "Gangster";
    private const string PrintedText = "Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь Ваш текст здесь";
    public static string CurrentText { get; set; } = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            OnUpdate = StateHasChanged;
            IsLoading = true;
            CurrentText = string.Empty;
            StateHasChanged();
            await LoadSceneAsync();
        }
    }

    private async Task LoadSceneAsync()
    {
        var sceneRemotePath = $"{DService.ScenesRemoteDirectory}/{SceneName}.glb";
        var sceneLocalPath = Path.Combine(HostingEnvironment.WebRootPath, "models\\" + SceneName + ".glb");

        if (!File.Exists(sceneLocalPath))
            await DService.DownloadFileAsync(sceneRemotePath, sceneLocalPath);

        await JSRuntime.InvokeVoidAsync("RenderOnCanvasAsync", "render-canvas", $"{DService.ScenesLocalDirectory}/{SceneName}.glb");
    }
    private static async Task PrintTextAsync()
    {
        var textArray = PrintedText.ToCharArray();

        foreach (var character in textArray)
        {
            await Task.Delay(100);
            CurrentText += character;
            OnUpdate?.Invoke();
        }
    }

    [JSInvokable]
    public static void OnSceneReady()
    {
        IsLoading = false;
        PrintTextAsync();
    }
}
